# security

## Security Primitives
- controlling access to kube-apiserver
- Authentication
  - who can access?
- RBAC authorization
    - What can they do ?
- all communication is secured using TLS encryption
- all pods can access all other pods by default

## Authentication
- k8s does not manage user accounts natively
- relies on 3rd party services
- can manage service accounts natively
### Auth mechanisms
- for static password and token files, use a volume mount
1. static password file
- pass csv file to kube-apiserver with`basic-auth-file` flag
```csv
password,user,uid,groups
```
```yaml
apiVersion: v1
kind: Pod
metadata:
    name: kube-apiserver
spec:
    containers:
    - command:
        - kube-apiserver
        ...
        - --basic-auth-file=user-details.csv
```
- to authenticate, use the command
```bash
curl -v -k https://master-node:6443/api/v1/pods -u "user:password" 
```
2. static token file
`--token-auth-file` flag
```csv
token123,user,uid,groups
```
- to authenticate, use the command
```bash
curl -kv https://master-node:6443/api/v1/pods \
--header "Authorization: Bearer token123"
```
3. certificates
4. identity providers

## TLS introduction
- Transport Layer Security
- certs are used to guaranteed trust between 2 parties

## TLS in k8s
*.pem - server cert
*.key - private key
- all communication must be done via TLS
### server certs
1. kube-api 
- apiserver.crt
- apiserver.key
- the only client that talks to etcd server 
1b. kube-api to kubelet
- apiserver-kubelet-client.crt
- apiserver.kubelet-client.key
2. etcd
- etcdserver.crt
- etcdserver.key
3. kubelet
- kubelet.crt
- kubelet.key
### clients
1. admin
- admin.crt
- admin.key
2. kube-scheduler
- scheduler.crt
- scheduler.key
3. kube-controller-manager
- controller-manager.crt
- controller-manager.key
4. kube-proxy
- kube-proxy.crt
- kube-proxy.key
### Certificate authority 
- must have at least 1 CA for the cluster
- can have 1 CA for etcd and 1 for others
- ca.cert
- ca.key
### Certificate creation
```bash
# 1. create private key
openssl genrsa -out ca.key 2048
# 2. create certificate signing request
openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr
# 3. create self signed certificate 
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```
### Client certificate
```bash
# 1. create private key
openssl genrsa -out admin.key 2048
# 2. create certificate signing request
openssl req -new -key admin.key -subj "/CN=kube-admin" -out admin.csr
# 2.b can include permissions in the certificate as well 
openssl req -new -key admin.key \
-subj "/CN=kube-admin/O=system:masters" -out admin.csr
# 3. openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt
openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt
```
### other core components
- `SYSTEM:KUBE-SCHEDULER`
- `SYSTEM:KUBE-CONTROLLER-MANAGER`
- `SYSTEM:KUBE-PROXY`
### Using via curl
```bash
curl https://kube-apiserver:6443/api/v1/pods \
--key admin.key --cert admin.crt --cacert ca.crt
```
### using via kube-config.yaml
```yaml
apiVersion: v1
clusters:
- cluster:
    certificate-authority: ca.crt
    server: https://kube-apiserver.:6443
  name: kubernetes
kind: Config
...
```
### etcd server
- generate additional peer certs for distributed setup
### kube-api server
- all components talk to kube-api server
- some call it 
    - kubernetes 
    - kubernetes.default
    - kubernetes.default.svc
    - kubernetes.default.svc.cluster.local
    - <IP_ADDRESS>
- specify Subject alternate names
```cnf
...
[alt names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
IP.1 = <IP_ADDRESS>
...
```
### kubelet 
- https API server that runs on each node (captain)
- talks to kube-api server
- these certs are named after their nodes e.g node01, node02 etc
- `system:node:node01` is used as the CN 

### View certificates 
1. The hard way 
- generate certs manually via openssl
2. kubeadm
- takes care of everything
### checking logs for certs
```bash
journalctl -fu etcd.service 

kubectl logs etcd-master

# 1 level down 
docker ps -a | grep etcd
```
### Cert Signing process
1. create `CertificateSigningRequest` object
- must be in base64
```yaml
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
    name: foo
spec:
    groups:
    - system:authenticated
    usages:
    - digital signature
    - key encipherment
    - server auth
    request: 
        <base64 encoded CSR>
```
2. review requests
```bash
k get csr
```
3. approve request
```yaml
k certificate approve jane
```
### Cert related operations
- carried out by the `Controller manager`
- controllers
1. csr-approving 
2. csr-signing

### Lab
```yaml
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
    name: akshay
spec:
    groups:
    - system:authenticated
    signerName: kubernetes.io/kube-apiserver-client
    usages:
    - client auth
    request: <base64>
```
```bash
# 1. convert csr to base64
cat akshay.csr |base64 -w 0
# 2. create csr object
kubectl apply -f csr.yaml
# 3. approve csr
k certificate approve akshay
# 4. delete csr
k delete csr/akshay
```